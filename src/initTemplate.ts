import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export async function maybeOfferInit(folder: string) {
	const choice = await vscode.window.showWarningMessage(
		'Mago: mago.toml was not found in this workspace. Initialize configuration?',
		'Create mago.toml from template',
		'Cancel'
	);
	if (choice === 'Create mago.toml from template') {
		await createTomlFromComposerTemplate(folder);
	}
}

export async function createTomlFromComposerTemplate(folder: string) {
	try {
		const tomlPath = path.join(folder, 'mago.toml');
		if (fs.existsSync(tomlPath)) {
			vscode.window.showInformationMessage('Mago: mago.toml already exists.');
			return;
		}
		let packageName: string | undefined;
		let phpVersion: string | undefined;
		try {
			const composerPath = path.join(folder, 'composer.json');
			if (fs.existsSync(composerPath)) {
				const composer = JSON.parse(fs.readFileSync(composerPath, 'utf8')) as any;
				packageName = typeof composer?.name === 'string' ? composer.name : undefined;
				const platformPhp: string | undefined = composer?.config?.platform?.php;
				const requirePhp: string | undefined = composer?.require?.php;
				const constraint: string | undefined = platformPhp || requirePhp;
				phpVersion = constraint ? derivePhpVersionFromConstraint(constraint) : undefined;
			}
		} catch { }
		const header = ['# Generated by Mago VS Code extension', packageName ? `# Project: ${packageName}` : undefined].filter(Boolean).join('\n');
		const resolvedPhpVersion = phpVersion || '8.4.0';
		const TEMPLATE = `# Welcome to Mago!\n# For full documentation, see https://mago.carthage.software/tools/overview\nphp-version = "${resolvedPhpVersion}"\n\n[source]\n# Source roots for analysis\npaths = ["src/"]\n# Additional include paths (e.g. vendor)\nincludes = ["vendor"]\n\n[formatter]\nprint-width = 120\ntab-width = 4\nuse-tabs = false\n\n[linter]\n# External tooling integrations (empty by default)\nintegrations = []\n\n[linter.rules]\n# Example rule overrides\nambiguous-function-call = { enabled = false }\nliteral-named-argument = { enabled = false }\nhalstead = { effort-threshold = 7000 }\n\n[analyzer]\n# General options\n# excludes: A list of paths or glob patterns to exclude from analysis. (default: [])\nexcludes = [\n    "vendor/**"\n]\n# ignore: A list of issue codes to ignore globally, e.g. "mixed-argument" (default: [])\n# ignore = [\n#   "mixed-argument"\n# ]\n\n# Feature flags (defaults shown in comments)\n# find-unused-expressions: Find expressions whose results are not used. (default: true)\nfind-unused-expressions = false\n# find-unused-definitions: Find unused definitions (e.g., unused private methods). (default: true)\nfind-unused-definitions = true\n# analyze-dead-code: Analyze code that appears unreachable. (default: true)\nanalyze-dead-code = false\n# check-throws: Check for unhandled thrown exceptions not documented with @throws. (default: true)\ncheck-throws = true\n# allow-possibly-undefined-array-keys: Allow accessing possibly undefined array keys. (default: true)\nallow-possibly-undefined-array-keys = true\n# perform-heuristic-checks: Perform extra heuristic checks for potential issues. (default: true)\nperform-heuristic-checks = true\n# memoize-properties: Track literal values of class properties (may increase memory). (default: false)\n# memoize-properties = false\n\n# Issue categories (all default to true)\n# mixed-issues = true            # Mixed type usage\n# falsable-issues = true         # Possibly false values\n# nullable-issues = true         # Possibly null values\n# redundancy-issues = true       # Redundant code\n# reference-issues = true        # By-reference variables\n# unreachable-issues = true      # Unreachable code\n# deprecation-issues = true      # Deprecated code usage\n# impossibility-issues = true    # Logically impossible conditions\n# ambiguity-issues = true        # Ambiguous constructs\n# existence-issues = true        # Symbol existence problems\n# template-issues = true         # Generic template types\n# argument-issues = true         # Function arguments\n# operand-issues = true          # Expression operands\n# property-issues = true         # Class properties\n# generator-issues = true        # Generators\n# array-issues = true            # Array operations\n# return-issues = true           # Function/method return types\n# method-issues = true           # Methods and their usage\n# iterator-issues = true         # Iterators\n`;
		const content = `${header}\n\n${TEMPLATE}`;
		fs.writeFileSync(tomlPath, content, { encoding: 'utf8' });
		vscode.window.showInformationMessage('Mago: created mago.toml from template.');
		vscode.window.showTextDocument(vscode.Uri.file(tomlPath));
	} catch (e: any) {
		vscode.window.showErrorMessage(`Mago: failed to create mago.toml: ${e?.message || e}`);
	}
}

function derivePhpVersionFromConstraint(constraint: string): string | undefined {
	const matches = [...constraint.matchAll(/(\d+)\.(\d+)(?:\.(\d+))?/g)];
	if (matches.length === 0) { return undefined; }
	let best: { major: number; minor: number; patch: number } | undefined;
	for (const m of matches) {
		const major = Number(m[1]);
		const minor = Number(m[2]);
		const patch = m[3] !== undefined ? Number(m[3]) : 0;
		if (!best) { best = { major, minor, patch }; continue; }
		if (major > best.major || (major === best.major && (minor > best.minor || (minor === best.minor && patch > best.patch)))) {
			best = { major, minor, patch };
		}
	}
	if (!best) { return undefined; }
	return `${best.major}.${best.minor}.${best.patch}`;
}


